<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å›´æ£‹æ£‹ç›˜è¯†åˆ« - OpenCV</title>
    
    <!-- OpenCV.js -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        /* è§†é¢‘è¾“å…¥ï¼ˆéšè—ï¼‰ */
        #videoInput {
            display: none;
        }
        
        /* ä¸»æ˜¾ç¤ºç”»å¸ƒ */
        #canvasOutput {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 0 40px rgba(0,0,0,0.8);
        }
        
        /* UI å±‚ */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .panel {
            position: absolute;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        
        #statusPanel {
            top: 20px;
            left: 20px;
            min-width: 200px;
        }
        
        #controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        #fpsCounter {
            top: 20px;
            right: 20px;
            font-family: monospace;
            color: #00ff00;
        }
        
        .btn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:hover { background: #0056b3; }
        .btn:disabled { background: #666; opacity: 0.6; }
        .btn.active { background: #34C759; }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
            z-index: 100;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: #007AFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 13px;
        }
        
        .stat-label { color: #aaa; }
        .stat-value { color: #fff; font-weight: 600; }
        
        #debugInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            max-width: 250px;
            text-align: right;
        }
    </style>
</head>
<body>

<div id="container">
    <!-- åŠ è½½æç¤º -->
    <div id="loading">
        <div class="spinner"></div>
        <div>æ­£åœ¨åŠ è½½ OpenCV å¼•æ“...</div>
        <div style="font-size: 12px; opacity: 0.7; margin-top: 10px;">é¦–æ¬¡åŠ è½½çº¦éœ€ 5-10 ç§’</div>
    </div>
    
    <!-- è§†é¢‘è¾“å…¥ -->
    <video id="videoInput" playsinline></video>
    
    <!-- è¾“å‡ºç”»å¸ƒ -->
    <canvas id="canvasOutput"></canvas>
    
    <!-- UI å±‚ -->
    <div id="ui" style="display: none;">
        <div class="panel" id="statusPanel">
            <div style="font-weight: 600; margin-bottom: 10px; color: #007AFF;">ğŸ“¹ æ£‹ç›˜æ£€æµ‹çŠ¶æ€</div>
            <div class="stat-row">
                <span class="stat-label">æ£€æµ‹çŠ¶æ€</span>
                <span class="stat-value" id="detectStatus">æœªå¼€å§‹</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">æ£‹ç›˜è§’ç‚¹</span>
                <span class="stat-value" id="cornerCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">æ˜Ÿä½æ ‡è®°</span>
                <span class="stat-value" id="starCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">é€è§†è´¨é‡</span>
                <span class="stat-value" id="qualityScore">-</span>
            </div>
        </div>
        
        <div class="panel" id="fpsCounter">
            FPS: <span id="fps">0</span>
        </div>
        
        <div class="panel" id="controls">
            <button class="btn" id="btnStart" onclick="startCamera()" disabled>å¯åŠ¨ç›¸æœº</button>
            <button class="btn" id="btnPause" onclick="togglePause()" disabled>æš‚åœ</button>
            <button class="btn" onclick="toggleDebug()">è°ƒè¯•æ¨¡å¼</button>
        </div>
        
        <div id="debugInfo">
            æç¤ºï¼šç¡®ä¿æ£‹ç›˜å…‰çº¿å……è¶³ã€å¯¹æ¯”åº¦æ˜æ˜¾<br>
            æ”¯æŒ 9/13/19 è·¯æ ‡å‡†æ£‹ç›˜
        </div>
    </div>
</div>

<script>
let cv = null;
let video = document.getElementById('videoInput');
let canvas = document.getElementById('canvasOutput');
let ctx = canvas.getContext('2d');
let isProcessing = false;
let isPaused = false;
let debugMode = false;
let lastTime = 0;
let fps = 0;

// æ£€æµ‹å‚æ•°
const PARAMS = {
    cannyThreshold1: 50,
    cannyThreshold2: 150,
    houghThreshold: 100,
    minLineLength: 100,
    maxLineGap: 10,
    cornerQuality: 0.01,
    cornerMinDist: 20
};

// æ£‹ç›˜çŠ¶æ€
let boardState = {
    detected: false,
    corners: [],
    stars: [],
    gridSize: 19,
    homography: null
};

// OpenCV åŠ è½½å®Œæˆ
function onOpenCvReady() {
    cv = window.cv;
    document.getElementById('loading').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    document.getElementById('btnStart').disabled = false;
    console.log('OpenCV.js åŠ è½½å®Œæˆï¼Œç‰ˆæœ¬:', cv.getBuildInformation);
}

// å¯åŠ¨æ‘„åƒå¤´
async function startCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                facingMode: 'environment', // åç½®æ‘„åƒå¤´
                width: { ideal: 1280 },
                height: { ideal: 720 }
            }
        });
        
        video.srcObject = stream;
        video.play();
        
        document.getElementById('btnStart').textContent = 'ç›¸æœºè¿è¡Œä¸­';
        document.getElementById('btnStart').classList.add('active');
        document.getElementById('btnPause').disabled = false;
        
        // ç­‰å¾…è§†é¢‘å°±ç»ª
        video.onloadedmetadata = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            isProcessing = true;
            requestAnimationFrame(processFrame);
        };
        
    } catch (err) {
        alert('æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: ' + err.message);
    }
}

// æš‚åœ/ç»§ç»­
function togglePause() {
    isPaused = !isPaused;
    document.getElementById('btnPause').textContent = isPaused ? 'ç»§ç»­' : 'æš‚åœ';
}

// åˆ‡æ¢è°ƒè¯•æ¨¡å¼
function toggleDebug() {
    debugMode = !debugMode;
}

// ä¸»å¤„ç†å¾ªç¯
function processFrame(timestamp) {
    if (!isProcessing) return;
    
    // è®¡ç®— FPS
    if (timestamp - lastTime > 1000) {
        document.getElementById('fps').textContent = fps;
        fps = 0;
        lastTime = timestamp;
    }
    fps++;
    
    if (!isPaused && video.readyState === 4) {
        // ç»˜åˆ¶åŸå›¾
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // OpenCV å¤„ç†
        detectBoard();
    }
    
    requestAnimationFrame(processFrame);
}

// æ ¸å¿ƒæ£€æµ‹é€»è¾‘
function detectBoard() {
    if (!cv) return;
    
    try {
        // è¯»å–å½“å‰å¸§åˆ° Mat
        let src = cv.imread(canvas);
        let gray = new cv.Mat();
        let blurred = new cv.Mat();
        
        // 1. é¢„å¤„ç†ï¼šç°åº¦ + é«˜æ–¯æ¨¡ç³Š
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
        
        // 2. è¾¹ç¼˜æ£€æµ‹
        let edges = new cv.Mat();
        cv.Canny(blurred, edges, PARAMS.cannyThreshold1, PARAMS.cannyThreshold2);
        
        // 3. è†¨èƒ€è¿æ¥æ–­çº¿
        let dilated = new cv.Mat();
        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
        cv.dilate(edges, dilated, kernel);
        
        // 4. æŸ¥æ‰¾è½®å»“
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(dilated, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        
        // 5. å¯»æ‰¾æœ€å¤§å››è¾¹å½¢ï¼ˆæ£‹ç›˜ï¼‰
        let boardContour = findBoardContour(contours);
        
        if (boardContour) {
            // 6. é€è§†æ ¡æ­£
            let warped = warpPerspective(src, boardContour);
            
            // 7. åœ¨æ ¡æ­£åçš„å›¾åƒä¸Šæ£€æµ‹æ˜Ÿä½
            let stars = detectStars(warped);
            
            // 8. å°†æ˜Ÿä½æ˜ å°„å›åŸå›¾å¹¶ç»˜åˆ¶
            drawResults(src, boardContour, stars);
            
            // 9. æ›´æ–° UI
            updateUI(true, boardContour.rows, stars.length);
            
            warped.delete();
        } else {
            updateUI(false, 0, 0);
        }
        
        // æ¸…ç†
        src.delete(); gray.delete(); blurred.delete();
        edges.delete(); dilated.delete(); kernel.delete();
        contours.delete(); hierarchy.delete();
        
    } catch (e) {
        console.error('æ£€æµ‹é”™è¯¯:', e);
    }
}

// å¯»æ‰¾æ£‹ç›˜è½®å»“
function findBoardContour(contours) {
    let maxArea = 0;
    let bestContour = null;
    
    for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        
        // è¿‡æ»¤å¤ªå°çš„åŒºåŸŸ
        if (area < canvas.width * canvas.height * 0.1) continue;
        
        // è¿‘ä¼¼å¤šè¾¹å½¢
        let peri = cv.arcLength(cnt, true);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
        
        // å¯»æ‰¾å››è¾¹å½¢
        if (approx.rows === 4 && area > maxArea) {
            maxArea = area;
            bestContour = approx.clone();
        }
        
        approx.delete();
        cnt.delete();
    }
    
    return bestContour;
}

// é€è§†æ ¡æ­£
function warpPerspective(src, contour) {
    // è·å–å››ä¸ªè§’ç‚¹
    let points = [];
    for (let i = 0; i < 4; i++) {
        points.push({
            x: contour.data32S[i * 2],
            y: contour.data32S[i * 2 + 1]
        });
    }
    
    // æ’åºè§’ç‚¹ï¼šå·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹
    points.sort((a, b) => a.y - b.y);
    let top = points.slice(0, 2).sort((a, b) => a.x - b.x);
    let bottom = points.slice(2).sort((a, b) => a.x - b.x);
    let ordered = [top[0], top[1], bottom[1], bottom[0]];
    
    // ç›®æ ‡æ­£æ–¹å½¢
    let size = 800;
    let dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
        0, 0,
        size, 0,
        size, size,
        0, size
    ]);
    
    let srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
        ordered[0].x, ordered[0].y,
        ordered[1].x, ordered[1].y,
        ordered[2].x, ordered[2].y,
        ordered[3].x, ordered[3].y
    ]);
    
    // è®¡ç®—å˜æ¢çŸ©é˜µ
    let M = cv.getPerspectiveTransform(srcPoints, dstPoints);
    let warped = new cv.Mat();
    cv.warpPerspective(src, warped, M, new cv.Size(size, size));
    
    // ä¿å­˜è§’ç‚¹ä¾›åç»­ä½¿ç”¨
    boardState.corners = ordered;
    
    M.delete(); srcPoints.delete(); dstPoints.delete();
    
    return warped;
}

// æ£€æµ‹æ˜Ÿä½ï¼ˆ9ä¸ªé»‘ç‚¹ï¼‰
function detectStars(warped) {
    let gray = new cv.Mat();
    cv.cvtColor(warped, gray, cv.COLOR_RGBA2GRAY);
    
    // äºŒå€¼åŒ–
    let binary = new cv.Mat();
    cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
    
    // æŸ¥æ‰¾åœ†/æ–‘ç‚¹ï¼ˆæ˜Ÿä½ï¼‰
    let circles = new cv.Mat();
    cv.HoughCircles(gray, circles, cv.HOUGH_GRADIENT, 1, 30, 50, 20, 5, 30);
    
    let stars = [];
    let size = warped.rows;
    let cellSize = size / 18; // 19è·¯æ£‹ç›˜
    
    // éªŒè¯æ£€æµ‹åˆ°çš„åœ†æ˜¯å¦åœ¨æ ‡å‡†æ˜Ÿä½ä½ç½®
    const starPositions = [
        [3, 3], [3, 9], [3, 15],
        [9, 3], [9, 9], [9, 15],
        [15, 3], [15, 9], [15, 15]
    ];
    
    for (let i = 0; i < circles.cols; i++) {
        let x = circles.data32F[i * 3];
        let y = circles.data32F[i * 3 + 1];
        let r = circles.data32F[i * 3 + 2];
        
        // è½¬æ¢ä¸ºç½‘æ ¼åæ ‡
        let gridX = Math.round(x / cellSize);
        let gridY = Math.round(y / cellSize);
        
        // æ£€æŸ¥æ˜¯å¦åŒ¹é…æ ‡å‡†æ˜Ÿä½
        let isStar = starPositions.some(pos => 
            Math.abs(pos[0] - gridX) <= 1 && Math.abs(pos[1] - gridY) <= 1
        );
        
        if (isStar) {
            stars.push({ x, y, gridX, gridY, r });
        }
    }
    
    gray.delete(); binary.delete(); circles.delete();
    
    return stars;
}

// ç»˜åˆ¶ç»“æœ
function drawResults(src, contour, stars) {
    // ç»˜åˆ¶æ£‹ç›˜è½®å»“
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 3;
    ctx.beginPath();
    
    for (let i = 0; i < 4; i++) {
        let x = contour.data32S[i * 2];
        let y = contour.data32S[i * 2 + 1];
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
    
    // ç»˜åˆ¶è§’ç‚¹
    ctx.fillStyle = '#ff0000';
    for (let i = 0; i < 4; i++) {
        let x = contour.data32S[i * 2];
        let y = contour.data32S[i * 2 + 1];
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();
        
        // æ ‡æ³¨ç¼–å·
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px sans-serif';
        ctx.fillText(String(i+1), x + 10, y - 10);
        ctx.fillStyle = '#ff0000';
    }
    
    // ç»˜åˆ¶æ˜Ÿä½ï¼ˆæ˜ å°„å›åŸå›¾åæ ‡ï¼‰
    if (stars.length > 0 && boardState.corners.length === 4) {
        // è®¡ç®—é€†é€è§†å˜æ¢
        let size = 800;
        let dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, size, 0, size, size, 0, size]);
        let srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
            boardState.corners[0].x, boardState.corners[0].y,
            boardState.corners[1].x, boardState.corners[1].y,
            boardState.corners[2].x, boardState.corners[2].y,
            boardState.corners[3].x, boardState.corners[3].y
        ]);
        
        let M = cv.getPerspectiveTransform(dstPoints, srcPoints);
        
        stars.forEach((star, idx) => {
            // å˜æ¢åæ ‡
            let pt = cv.matFromArray(1, 1, cv.CV_32FC2, [star.x, star.y]);
            let transformed = new cv.Mat();
            cv.perspectiveTransform(pt, transformed, M);
            
            let tx = transformed.data32F[0];
            let ty = transformed.data32F[1];
            
            // ç»˜åˆ¶æ˜Ÿä½æ ‡è®°
            ctx.strokeStyle = '#007AFF';
            ctx.fillStyle = 'rgba(0, 122, 255, 0.3)';
            ctx.lineWidth = 2;
            
            // å¤–åœˆ
            ctx.beginPath();
            ctx.arc(tx, ty, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // åå­—
            ctx.beginPath();
            ctx.moveTo(tx - 10, ty);
            ctx.lineTo(tx + 10, ty);
            ctx.moveTo(tx, ty - 10);
            ctx.lineTo(tx, ty + 10);
            ctx.stroke();
            
            // ç¼–å·
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText(`â˜…${idx+1}`, tx + 18, ty + 4);
            
            pt.delete(); transformed.delete();
        });
        
        M.delete(); dstPoints.delete(); srcPoints.delete();
    }
    
    // è°ƒè¯•ä¿¡æ¯
    if (debugMode) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(10, canvas.height - 100, 300, 90);
        ctx.fillStyle = '#0f0';
        ctx.font = '12px monospace';
        ctx.fillText(`Contours detected`, 20, canvas.height - 80);
        ctx.fillText(`Board area: ${cv.contourArea(contour).toFixed(0)} pxÂ²`, 20, canvas.height - 60);
        ctx.fillText(`Stars found: ${stars.length}/9`, 20, canvas.height - 40);
        ctx.fillText(`Confidence: ${(stars.length/9*100).toFixed(0)}%`, 20, canvas.height - 20);
    }
}

// æ›´æ–° UI
function updateUI(detected, corners, stars) {
    document.getElementById('detectStatus').textContent = detected ? 'âœ… å·²æ£€æµ‹' : 'âŒ æœªæ£€æµ‹';
    document.getElementById('detectStatus').style.color = detected ? '#34C759' : '#FF3B30';
    document.getElementById('cornerCount').textContent = corners;
    document.getElementById('starCount').textContent = `${stars}/9`;
    
    let quality = '-';
    if (detected) {
        if (stars >= 7) quality = 'ä¼˜ç§€';
        else if (stars >= 5) quality = 'è‰¯å¥½';
        else if (stars >= 3) quality = 'ä¸€èˆ¬';
        else quality = 'è¾ƒå·®';
    }
    document.getElementById('qualityScore').textContent = quality;
    document.getElementById('qualityScore').style.color = 
        quality === 'ä¼˜ç§€' ? '#34C759' : 
        quality === 'è‰¯å¥½' ? '#007AFF' : 
        quality === 'ä¸€èˆ¬' ? '#FF9500' : '#FF3B30';
}

// æ¸…ç†
window.onbeforeunload = () => {
    isProcessing = false;
};
</script>

</body>
</html>
