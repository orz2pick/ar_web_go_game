<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å›´æ£‹æ£‹ç›˜è¯†åˆ« - å±€éƒ¨æ£€æµ‹ç‰ˆ</title>
    
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #videoInput { display: none; }
        
        #canvasOutput {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 0 40px rgba(0,0,0,0.8);
        }
        
        #ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .panel {
            position: absolute;
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        
        #statusPanel {
            top: 20px; left: 20px;
            min-width: 220px;
        }
        
        #controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        #fpsCounter {
            top: 20px; right: 20px;
            font-family: monospace;
            color: #00ff00;
        }
        
        /* æ–°å¢ï¼šè¦†ç›–ç‡æ˜¾ç¤º */
        .coverage-display {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        #coverageFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #FF3B30, #FF9500, #34C759);
            transition: width 0.3s ease;
        }
        
        .grid-badge {
            display: inline-block;
            background: #007AFF;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-left: 5px;
        }
        
        .grid-badge.locked {
            background: #34C759;
        }
        
        .btn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .btn:disabled { background: #666; opacity: 0.6; }
        .btn.active { background: #34C759; }
        .btn.danger { background: #FF3B30; }
        
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
            z-index: 100;
        }
        
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: #007AFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 13px;
        }
        
        .stat-label { color: #aaa; }
        .stat-value { color: #fff; font-weight: 600; }
        .stat-value.good { color: #34C759; }
        .stat-value.warn { color: #FF9500; }
        .stat-value.bad { color: #FF3B30; }
    </style>
</head>
<body>

<div id="container">
    <div id="loading">
        <div class="spinner"></div>
        <div>æ­£åœ¨åŠ è½½ OpenCV å¼•æ“...</div>
    </div>
    
    <video id="videoInput" playsinline></video>
    <canvas id="canvasOutput"></canvas>
    
    <div id="ui" style="display: none;">
        <div class="panel" id="statusPanel">
            <div style="font-weight: 600; margin-bottom: 10px; color: #007AFF;">
                ğŸ“¹ æ£‹ç›˜æ£€æµ‹çŠ¶æ€
            </div>
            
            <div class="stat-row">
                <span class="stat-label">æ£‹ç›˜è§„æ ¼</span>
                <span class="stat-value" id="boardType">
                    æ£€æµ‹ä¸­... <span class="grid-badge" id="lockBadge">AUTO</span>
                </span>
            </div>
            
            <!-- æ–°å¢ï¼šå±€éƒ¨è¦†ç›–ç‡æ˜¾ç¤º -->
            <div class="coverage-display">
                <div class="stat-row">
                    <span class="stat-label">è§†é‡è¦†ç›–ç‡</span>
                    <span class="stat-value" id="coverageText">0%</span>
                </div>
                <div class="progress-bar">
                    <div id="coverageFill"></div>
                </div>
                <div style="font-size: 11px; color: #aaa; margin-top: 4px;" id="coverageDetail">
                    ç§»åŠ¨ç›¸æœºä»¥å®Œæ•´æ˜¾ç¤ºæ£‹ç›˜
                </div>
            </div>
            
            <div class="stat-row" style="margin-top: 8px;">
                <span class="stat-label">æ£‹ç›˜è§’ç‚¹</span>
                <span class="stat-value" id="cornerCount">0/4</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">æ˜Ÿä½æ ‡è®°</span>
                <span class="stat-value" id="starCount">0</span>
            </div>
        </div>
        
        <div class="panel" id="fpsCounter">
            FPS: <span id="fps">0</span>
        </div>
        
        <div class="panel" id="controls">
            <button class="btn" id="btnStart" onclick="startCamera()" disabled>å¯åŠ¨ç›¸æœº</button>
            <button class="btn" onclick="resetBoard()">é‡ç½®è§„æ ¼</button>
        </div>
    </div>
</div>

<script>
let cv = null;
let video = document.getElementById('videoInput');
let canvas = document.getElementById('canvasOutput');
let ctx = canvas.getContext('2d');
let isProcessing = false;

// æ–°å¢ï¼šæ£‹ç›˜é…ç½®çŠ¶æ€
let boardConfig = {
    isInitialized: false,  // æ˜¯å¦å·²é¦–æ¬¡æ£€æµ‹
    gridSize: 19,          // 9, 13, æˆ– 19
    locked: false,         // é”å®šåä¸å†æ”¹å˜
    coverage: 0,           // å½“å‰è¦†ç›–ç‡ 0-100
    coverageHistory: []    // ç”¨äºå¹³æ»‘
};

function onOpenCvReady() {
    cv = window.cv;
    document.getElementById('loading').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    document.getElementById('btnStart').disabled = false;
}

async function startCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment', width: 1280, height: 720 }
        });
        
        video.srcObject = stream;
        video.play();
        
        document.getElementById('btnStart').textContent = 'è¿è¡Œä¸­';
        document.getElementById('btnStart').classList.add('active');
        
        video.onloadedmetadata = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            isProcessing = true;
            requestAnimationFrame(processFrame);
        };
        
    } catch (err) {
        alert('æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: ' + err.message);
    }
}

function resetBoard() {
    boardConfig.isInitialized = false;
    boardConfig.locked = false;
    boardConfig.gridSize = 19;
    boardConfig.coverageHistory = [];
    document.getElementById('boardType').innerHTML = 'æ£€æµ‹ä¸­... <span class="grid-badge" id="lockBadge">AUTO</span>';
    updateCoverage(0, false);
}

let lastTime = 0, fps = 0;
function processFrame(timestamp) {
    if (!isProcessing) return;
    
    if (timestamp - lastTime > 1000) {
        document.getElementById('fps').textContent = fps;
        fps = 0;
        lastTime = timestamp;
    }
    fps++;
    
    if (video.readyState === 4) {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        detectBoard();
    }
    
    requestAnimationFrame(processFrame);
}

function detectBoard() {
    if (!cv) return;
    
    try {
        let src = cv.imread(canvas);
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        
        let blurred = new cv.Mat();
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
        
        let edges = new cv.Mat();
        cv.Canny(blurred, edges, 50, 150);
        
        let dilated = new cv.Mat();
        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
        cv.dilate(edges, dilated, kernel);
        
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(dilated, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        
        let boardContour = findBoardContour(contours);
        
        if (boardContour) {
            processValidBoard(src, boardContour, gray);
        } else {
            updateCoverage(0, false);
            document.getElementById('cornerCount').textContent = '0/4';
            document.getElementById('starCount').textContent = '0';
        }
        
        src.delete(); gray.delete(); blurred.delete();
        edges.delete(); dilated.delete(); kernel.delete();
        contours.delete(); hierarchy.delete();
        if(boardContour) boardContour.delete();
        
    } catch (e) {
        console.error('æ£€æµ‹é”™è¯¯:', e);
    }
}

function findBoardContour(contours) {
    let maxArea = 0;
    let bestContour = null;
    
    for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        
        if (area < canvas.width * canvas.height * 0.05) continue;
        
        let peri = cv.arcLength(cnt, true);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
        
        if (approx.rows === 4 && area > maxArea) {
            maxArea = area;
            if (bestContour) bestContour.delete();
            bestContour = approx.clone();
        }
        
        approx.delete();
        cnt.delete();
    }
    
    return bestContour;
}

function processValidBoard(src, contour, gray) {
    // æå–è§’ç‚¹
    let pts = [];
    for(let i=0; i<4; i++) {
        pts.push({
            x: contour.data32S[i*2],
            y: contour.data32S[i*2+1]
        });
    }
    
    // æ’åºè§’ç‚¹
    pts.sort((a, b) => a.y - b.y);
    let top = pts.slice(0, 2).sort((a, b) => a.x - b.x);
    let bottom = pts.slice(2).sort((a, b) => a.x - b.x);
    let sortedPts = [top[0], top[1], bottom[1], bottom[0]];
    
    // è®¡ç®—é€è§†å˜æ¢
    const size = 800;
    let srcMat = cv.matFromArray(4, 1, cv.CV_32FC2, [
        sortedPts[0].x, sortedPts[0].y,
        sortedPts[1].x, sortedPts[1].y,
        sortedPts[2].x, sortedPts[2].y,
        sortedPts[3].x, sortedPts[3].y
    ]);
    let dstMat = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, size, 0, size, size, 0, size]);
    let M = cv.getPerspectiveTransform(srcMat, dstMat);
    let invM = cv.getPerspectiveTransform(dstMat, srcMat);
    
    let warped = new cv.Mat();
    cv.warpPerspective(gray, warped, M, new cv.Size(size, size));
    
    // é¦–æ¬¡æ£€æµ‹ï¼šåˆ¤å®šè·¯æ•°
    if (!boardConfig.isInitialized) {
        detectInitialGridSize(warped);
    }
    
    // è®¡ç®—è¦†ç›–ç‡
    let coverage = calculateCoverage(sortedPts);
    updateCoverage(coverage, true);
    
    // æ£€æµ‹æ˜Ÿä½
    let stars = detectStars(warped, invM);
    
    // ç»˜åˆ¶
    drawBoardOverlay(sortedPts, invM, stars);
    
    // æ›´æ–°UI
    document.getElementById('cornerCount').textContent = '4/4';
    document.getElementById('starCount').textContent = stars.length;
    
    // æ¸…ç†
    warped.delete(); M.delete(); invM.delete(); srcMat.delete(); dstMat.delete();
}

// æ–°å¢ï¼šé¦–æ¬¡æ£€æµ‹è·¯æ•°
function detectInitialGridSize(warped) {
    let edges = new cv.Mat();
    cv.Canny(warped, edges, 50, 150);
    
    let lines = new cv.Mat();
    cv.HoughLinesP(edges, lines, 1, Math.PI/180, 50, 100, 10);
    
    // åˆ†ç±»æ¨ªç«–çº¿
    let hLines = 0, vLines = 0;
    for(let i=0; i<lines.rows; i++) {
        let x1 = lines.data32S[i*4], y1 = lines.data32S[i*4+1];
        let x2 = lines.data32S[i*4+2], y2 = lines.data32S[i*4+3];
        let angle = Math.abs(Math.atan2(y2-y1, x2-x1) * 180/Math.PI);
        
        if(angle < 20 || angle > 160) hLines++;
        else if(angle > 70 && angle < 110) vLines++;
    }
    
    let avg = (hLines + vLines) / 2;
    if(avg < 15) boardConfig.gridSize = 9;
    else if(avg < 25) boardConfig.gridSize = 13;
    else boardConfig.gridSize = 19;
    
    boardConfig.isInitialized = true;
    boardConfig.locked = true;
    
    // æ›´æ–°UIæ˜¾ç¤º
    let badge = document.getElementById('lockBadge');
    badge.textContent = 'LOCKED';
    badge.className = 'grid-badge locked';
    document.getElementById('boardType').innerHTML = 
        boardConfig.gridSize + 'è·¯æ£‹ç›˜ ' + badge.outerHTML;
    
    edges.delete(); lines.delete();
}

// æ–°å¢ï¼šè®¡ç®—è¦†ç›–ç‡ï¼ˆåŸºäºè§’ç‚¹æ˜¯å¦åœ¨ç”»é¢å†… + æ£‹ç›˜å¤§å°ï¼‰
function calculateCoverage(corners) {
    let visibleCorners = 0;
    let margin = 50; // è¾¹è·é˜ˆå€¼
    
    corners.forEach(p => {
        if(p.x > margin && p.x < canvas.width - margin &&
           p.y > margin && p.y < canvas.height - margin) {
            visibleCorners++;
        }
    });
    
    // è®¡ç®—æ£‹ç›˜é¢ç§¯å æ¯”
    let area = Math.abs(
        (corners[0].x * corners[1].y + corners[1].x * corners[2].y + 
         corners[2].x * corners[3].y + corners[3].x * corners[0].y) -
        (corners[0].y * corners[1].x + corners[1].y * corners[2].x + 
         corners[2].y * corners[3].x + corners[3].y * corners[0].x)
    ) / 2;
    
    let areaRatio = area / (canvas.width * canvas.height);
    
    // ç»¼åˆè¯„åˆ†
    let coverage = (visibleCorners/4) * 60 + Math.min(areaRatio * 300, 40);
    
    // å¹³æ»‘å¤„ç†
    boardConfig.coverageHistory.push(coverage);
    if(boardConfig.coverageHistory.length > 5) boardConfig.coverageHistory.shift();
    
    let avg = boardConfig.coverageHistory.reduce((a,b)=>a+b,0) / boardConfig.coverageHistory.length;
    return Math.round(Math.min(100, avg));
}

function updateCoverage(value, detected) {
    boardConfig.coverage = value;
    let fill = document.getElementById('coverageFill');
    let text = document.getElementById('coverageText');
    let detail = document.getElementById('coverageDetail');
    
    fill.style.width = value + '%';
    text.textContent = value + '%';
    
    if(!detected) {
        text.className = 'stat-value bad';
        detail.textContent = 'æœªæ£€æµ‹åˆ°æ£‹ç›˜';
        return;
    }
    
    if(value > 80) {
        text.className = 'stat-value good';
        detail.textContent = 'âœ“ æ£‹ç›˜å®Œæ•´å¯è§';
    } else if(value > 50) {
        text.className = 'stat-value warn';
        detail.textContent = 'è°ƒæ•´è§’åº¦ä»¥å®Œæ•´æ˜¾ç¤º';
    } else {
        text.className = 'stat-value bad';
        detail.textContent = 'è¯·é è¿‘æ£‹ç›˜';
    }
}

// æ–°å¢ï¼š19è·¯ç½‘æ ¼çº¿ç»˜åˆ¶
function drawBoardOverlay(corners, invM, stars) {
    // ç»˜åˆ¶å¤–æ¡†
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(corners[0].x, corners[0].y);
    for(let i=1; i<4; i++) ctx.lineTo(corners[i].x, corners[i].y);
    ctx.closePath();
    ctx.stroke();
    
    // ç»˜åˆ¶è§’ç‚¹
    ctx.fillStyle = '#ff0000';
    corners.forEach((p, i) => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px sans-serif';
        ctx.fillText(String(i+1), p.x+10, p.y-10);
        ctx.fillStyle = '#ff0000';
    });
    
    // ç»˜åˆ¶å®Œæ•´ç½‘æ ¼çº¿ï¼ˆ19è·¯ï¼‰
    const size = 800;
    const grid = boardConfig.gridSize;
    const step = size / (grid - 1);
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 1.5;
    
    // ç”Ÿæˆæ‰€æœ‰ç½‘æ ¼çº¿ç«¯ç‚¹
    let lines = [];
    for(let i=0; i<grid; i++) {
        lines.push(0, i*step, size, i*step);           // æ¨ªçº¿
        lines.push(i*step, 0, i*step, size);           // ç«–çº¿
    }
    
    // æ‰¹é‡å˜æ¢
    let srcPts = cv.matFromArray(lines.length/2, 1, cv.CV_32FC2, lines);
    let dstPts = new cv.Mat();
    cv.perspectiveTransform(srcPts, dstPts, invM);
    
    // ç»˜åˆ¶
    for(let i=0; i<dstPts.rows; i+=2) {
        let x1 = dstPts.data32F[i*2], y1 = dstPts.data32F[i*2+1];
        let x2 = dstPts.data32F[(i+1)*2], y2 = dstPts.data32F[(i+1)*2+1];
        
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    
    srcPts.delete(); dstPts.delete();
    
    // ç»˜åˆ¶æ˜Ÿä½
    stars.forEach((star, idx) => {
        ctx.strokeStyle = '#007AFF';
        ctx.fillStyle = 'rgba(0, 122, 255, 0.3)';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.arc(star.x, star.y, 15, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        
        // åå­—
        ctx.beginPath();
        ctx.moveTo(star.x-10, star.y);
        ctx.lineTo(star.x+10, star.y);
        ctx.moveTo(star.x, star.y-10);
        ctx.lineTo(star.x, star.y+10);
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px sans-serif';
        ctx.fillText(`â˜…${idx+1}`, star.x+18, star.y+4);
    });
}

function detectStars(warped, invM) {
    let binary = new cv.Mat();
    cv.threshold(warped, binary, 80, 255, cv.THRESH_BINARY_INV);
    
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(binary, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
    
    let stars = [];
    let size = warped.rows;
    let step = size / (boardConfig.gridSize - 1);
    
    // æ ‡å‡†æ˜Ÿä½ä½ç½®ï¼ˆæ ¹æ®è·¯æ•°ï¼‰
    let starPos = getStarPositions(boardConfig.gridSize);
    
    for(let i=0; i<contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        
        // å¤§å°è¿‡æ»¤
        let expected = Math.PI * Math.pow(step * 0.15, 2);
        if(area < expected * 0.3 || area > expected * 3) {
            cnt.delete();
            continue;
        }
        
        let moments = cv.moments(cnt);
        let cx = moments.m10 / moments.m00;
        let cy = moments.m01 / moments.m00;
        
        let gx = Math.round(cx / step);
        let gy = Math.round(cy / step);
        
        // æ£€æŸ¥æ˜¯å¦åŒ¹é…æ ‡å‡†æ˜Ÿä½
        let match = starPos.find(p => Math.abs(p.x-gx)<=1 && Math.abs(p.y-gy)<=1);
        if(match) {
            // æ˜ å°„å›åŸå›¾
            let pt = cv.matFromArray(1, 1, cv.CV_32FC2, [cx, cy]);
            let dst = new cv.Mat();
            cv.perspectiveTransform(pt, dst, invM);
            
            stars.push({
                x: dst.data32F[0],
                y: dst.data32F[1],
                gridX: gx,
                gridY: gy
            });
            
            pt.delete(); dst.delete();
        }
        
        cnt.delete();
    }
    
    // å»é‡
    stars = stars.filter((s, i, self) => 
        i === self.findIndex(t => t.gridX === s.gridX && t.gridY === s.gridY)
    );
    
    binary.delete(); contours.delete(); hierarchy.delete();
    return stars;
}

function getStarPositions(size) {
    if(size === 9) return [{x:2,y:2}, {x:2,y:6}, {x:4,y:4}, {x:6,y:2}, {x:6,y:6}];
    if(size === 13) return [{x:3,y:3}, {x:3,y:9}, {x:6,y:6}, {x:9,y:3}, {x:9,y:9}];
    return [
        {x:3,y:3}, {x:3,y:9}, {x:3,y:15},
        {x:9,y:3}, {x:9,y:9}, {x:9,y:15},
        {x:15,y:3}, {x:15,y:9}, {x:15,y:15}
    ];
}
</script>
</body>
</html>
