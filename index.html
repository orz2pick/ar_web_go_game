<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR.js + A-Frame + Babylon.js å›´æ£‹</title>
    
    <!-- AR.js with A-Frame -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    
    <!-- Babylon.js for advanced rendering -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: -apple-system, sans-serif; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px 20px;
        }
        
        .info-panel {
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 15px 25px;
            border-radius: 20px;
            text-align: center;
            font-size: 14px;
            align-self: center;
            backdrop-filter: blur(10px);
            max-width: 90%;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            pointer-events: auto;
        }
        
        button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        button.secondary { background: #5856D6; }
        button.danger { background: #FF3B30; }
        
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
            background: rgba(0,0,0,0.9);
            padding: 20px 40px;
            border-radius: 30px;
        }
        
        .marker-hint {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 20px;
            display: none;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="loading">æ­£åœ¨åˆå§‹åŒ– AR å¼•æ“...</div>
<div class="marker-hint" id="markerHint"></div>

<div id="ui-layer">
    <div class="info-panel">
        <div id="statusText">ğŸ“± å¯¹å‡† Hiro æ ‡è®°ï¼ˆæˆ–ç‚¹å‡»"åˆ‡æ¢æ¨¡å¼"ä½¿ç”¨è¡¨é¢æ”¾ç½®ï¼‰</div>
        <div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">
            å½“å‰ç©å®¶: <span id="currentPlayer" style="color: #FFD700;">é»‘æ–¹</span> | 
            æ‰‹æ•°: <span id="moveCount">0</span>
        </div>
    </div>
    
    <div class="controls">
        <button onclick="resetGame()">é‡æ–°å¼€å§‹</button>
        <button class="secondary" onclick="toggleMode()">åˆ‡æ¢ AR æ¨¡å¼</button>
        <button class="danger" onclick="undoMove()">æ‚”æ£‹</button>
    </div>
</div>

<!-- AR åœºæ™¯ -->
<a-scene 
    embedded 
    arjs="sourceType: webcam; trackingMethod: best; debugUIEnabled: false;"
    renderer="antialias: true; alpha: true; colorManagement: true; highRefreshRate: true"
    vr-mode-ui="enabled: false">
    
    <!-- èµ„æºç®¡ç† -->
    <a-assets>
        <!-- ä½¿ç”¨ Babylon.js ç”Ÿæˆæ£‹ç›˜çº¹ç† -->
        <canvas id="babylonTexture"></canvas>
        
        <!-- æ£‹å­å£°éŸ³ -->
        <audio id="stoneSound" src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleR0NZKrk7rNsGgxJkNTsvH0nDk+L0O+0dSQPUIjN7sqAJA9GhtLquHEkDkiGzO3JgCQPR4bR6bpwJBBBgsnutm4jEUGAxOu0bSITSHzH7bRuIxKHfsjttG0iE4t+yO2zbCASiny+7rRrHxCJdsHutWsfD4l1wO60ayAPh3O+7rNqHxCIcb7tsmkgD4dyv+60aSAQhXHA7bFoIhCEccDtr2giEIPwve2uaCASg++97KtgIBKI5rztqV8gE4njvO2pXiATiuO77qhfIBSK47nvqV4gFYnjue+qXiAYjOe976peIBmN5r3vp14gGo3mv++nXiAcjue986teICCO573yqV4gJY7nvfKpXiApjue+8qleICyO573zpV4gLY7nvvOlXiAujue+9KleIC+O5770pV4gMI7nvfSlXiAzjue99KVeIDSO577zpV4gNo7nvvOlXiA4jue+86VeIDmO577ypV4gOg7nvvKlXiA7jue+8qVeIDyO577xpV4gPo7nvvGlXiA+jue+8KVeIEGO5r7upV4gRY7mvu6lXiBJjua+7qVeIFGO5r7qpV4gVY7mvualXiBZjua+6pV4gWY7mvuKlXiBdjua+4qVeIGGO5r7epV4gZY7mvu6lXiBpjuW+3qVWA="></audio>
    </a-assets>

    <!-- ç¯å…‰ç³»ç»Ÿ -->
    <a-light type="ambient" color="#ffffff" intensity="0.6"></a-light>
    <a-light type="directional" color="#ffffff" intensity="0.8" position="1 2 1" cast-shadow="true"></a-light>
    <a-light type="point" color="#FFE4B5" intensity="0.4" position="0 2 0"></a-light>

    <!-- AR æ ‡è®°è¿½è¸ªï¼ˆHiro æ ‡è®°ï¼‰ -->
    <a-marker type="pattern" url="https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/data/patt.hiro" id="markerTarget" emitevents="true">
        
        <!-- å›´æ£‹æ£‹ç›˜å®ä½“ -->
        <a-entity id="goBoard" position="0 0 0" rotation="-90 0 0">
            
            <!-- æ£‹ç›˜åº•åº§ï¼ˆä½¿ç”¨ Babylon ç”Ÿæˆçš„çº¹ç†ï¼‰ -->
            <a-plane 
                id="boardPlane"
                width="0.8" 
                height="0.8"
                material="src: #babylonTexture; transparent: false; shader: flat"
                shadow="receive: true; cast: false"
                class="clickable">
            </a-plane>
            
            <!-- æ£‹ç›˜åšåº¦ -->
            <a-box position="0 0 -0.02" width="0.85" height="0.85" depth="0.04" color="#8B4513" shadow="cast: true"></a-box>
            
            <!-- æ£‹å­å®¹å™¨ -->
            <a-entity id="stonesContainer" position="0 0 0.02"></a-entity>
            
            <!-- äº¤äº’å¹³é¢ï¼ˆé€æ˜çš„ç‚¹å‡»å±‚ï¼‰ -->
            <a-plane 
                id="clickSurface"
                position="0 0 0.01"
                width="0.75"
                height="0.75"
                class="clickable"
                material="visible: false; transparent: true"
                raycaster-listener>
            </a-plane>
            
            <!-- æ˜Ÿä½æ ‡è®°ï¼ˆè¾…åŠ©è§†è§‰ï¼‰ -->
            <a-entity id="starPoints"></a-entity>
        </a-entity>
        
    </a-marker>

    <!-- ç›¸æœº -->
    <a-entity camera>
        <a-cursor 
            id="cursor"
            raycaster="objects: .clickable"
            color="#007AFF"
            scale="0.5 0.5 0.5"
            opacity="0.8">
        </a-cursor>
    </a-entity>
</a-scene>

<script>
// ==================== Babylon.js çº¹ç†ç”Ÿæˆå™¨ ====================
class GoBoardTextureGenerator {
    constructor() {
        this.canvas = document.getElementById('babylonTexture');
        this.canvas.width = 1024;
        this.canvas.height = 1024;
        this.engine = new BABYLON.Engine(this.canvas, true, { preserveDrawingBuffer: true, stencil: true });
        this.scene = new BABYLON.Scene(this.engine);
        this.generateTexture();
    }
    
    generateTexture() {
        const scene = this.scene;
        
        // ç›¸æœºï¼ˆæ­£äº¤ï¼‰
        const camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 1, BABYLON.Vector3.Zero(), scene);
        camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
        camera.orthoLeft = -1.2;
        camera.orthoRight = 1.2;
        camera.orthoTop = 1.2;
        camera.orthoBottom = -1.2;
        
        // å…‰æº
        new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        
        // æ£‹ç›˜èƒŒæ™¯ï¼ˆæœ¨è´¨æè´¨ï¼‰
        const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 2.4, height: 2.4}, scene);
        const woodMaterial = new BABYLON.StandardMaterial("wood", scene);
        woodMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.72, 0); // #E6B800
        woodMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        woodMaterial.roughness = 0.8;
        
        // ç¨‹åºæœ¨çº¹
        const woodTexture = new BABYLON.NoiseProceduralTexture("perlin", 256, scene);
        woodTexture.octaves = 3;
        woodTexture.persistence = 0.8;
        woodTexture.animationSpeedFactor = 0;
        woodMaterial.bumpTexture = woodTexture;
        woodMaterial.bumpTexture.level = 0.5;
        
        ground.material = woodMaterial;
        
        // åˆ›å»º 19 è·¯ç½‘æ ¼çº¿
        const lines = [];
        const start = -1.0;
        const end = 1.0;
        const step = 2.0 / 18; // 19æ¡çº¿ï¼Œ18ä¸ªé—´éš”
        
        // æ¨ªçº¿
        for(let i=0; i<19; i++) {
            const z = start + i * step;
            lines.push([new BABYLON.Vector3(start, 0.01, z), new BABYLON.Vector3(end, 0.01, z)]);
        }
        // ç«–çº¿
        for(let i=0; i<19; i++) {
            const x = start + i * step;
            lines.push([new BABYLON.Vector3(x, 0.01, start), new BABYLON.Vector3(x, 0.01, end)]);
        }
        
        const gridColor = new BABYLON.Color4(0.1, 0.1, 0.1, 1);
        BABYLON.MeshBuilder.CreateLineSystem("grid", {lines: lines, colors: Array(lines.length).fill([gridColor, gridColor])}, scene);
        
        // æ˜Ÿä½ï¼ˆ9ä¸ªé»‘ç‚¹ï¼‰
        const starPositions = [3, 9, 15];
        starPositions.forEach(i => {
            starPositions.forEach(j => {
                const x = start + i * step;
                const z = start + j * step;
                const star = BABYLON.MeshBuilder.CreateSphere("star", {diameter: 0.08}, scene);
                star.position = new BABYLON.Vector3(x, 0.02, z);
                const starMat = new BABYLON.StandardMaterial("starMat", scene);
                starMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                star.material = starMat;
            });
        });
        
        // æ¸²æŸ“ä¸€æ¬¡åˆ° Canvas
        this.engine.runRenderLoop(() => {
            scene.render();
            // åœæ­¢æ¸²æŸ“å¾ªç¯ï¼Œé™æ€çº¹ç†å³å¯
            setTimeout(() => this.engine.stopRenderLoop(), 100);
        });
    }
}

// ==================== æ¸¸æˆé€»è¾‘ ====================
const GameLogic = {
    state: {
        currentPlayer: 'black',
        stones: [], // {x, z, player, mesh}
        gridSize: 19,
        boardSize: 0.75, // ç±³
        isARMode: true
    },
    
    init() {
        // åˆå§‹åŒ– Babylon çº¹ç†
        new GoBoardTextureGenerator();
        
        // éšè—åŠ è½½
        document.getElementById('loading').style.display = 'none';
        
        // è®¾ç½®ç‚¹å‡»ç›‘å¬
        this.setupInteraction();
        
        // ç”Ÿæˆæ˜Ÿä½è¾…åŠ©æ ‡è®°ï¼ˆA-Frame åŸç”Ÿï¼Œå åŠ åœ¨ Babylon çº¹ç†ä¸Šï¼‰
        this.createStarMarkers();
    },
    
    createStarMarkers() {
        const container = document.getElementById('starPoints');
        const positions = [3, 9, 15];
        const step = 0.75 / 18; // ä¸ Babylon ä¸­çš„ step å¯¹åº”
        
        positions.forEach(i => {
            positions.forEach(j => {
                const marker = document.createElement('a-sphere');
                const x = -0.375 + i * step;
                const z = -0.375 + j * step;
                marker.setAttribute('position', `${x} 0.005 ${z}`);
                marker.setAttribute('radius', '0.008');
                marker.setAttribute('color', '#1a1a1a');
                container.appendChild(marker);
            });
        });
    },
    
    setupInteraction() {
        // ä½¿ç”¨ raycaster ç›‘å¬ç‚¹å‡»
        const clickSurface = document.getElementById('clickSurface');
        
        clickSurface.addEventListener('click', (e) => {
            if(!this.state.isARMode) return;
            
            // è·å–äº¤ç‚¹ä½ç½®
            const intersection = e.detail.intersection;
            if(!intersection) return;
            
            const point = intersection.point;
            
            // è½¬æ¢ä¸ºæ£‹ç›˜æœ¬åœ°åæ ‡ï¼ˆæ£‹ç›˜æ—‹è½¬äº† -90åº¦ Xè½´ï¼Œæ‰€ä»¥ Y åœ¨è¿™é‡Œæ˜¯é«˜åº¦ï¼‰
            // æ³¨æ„ï¼šA-Frame çš„åæ ‡ç³»ï¼Œæ£‹ç›˜æ˜¯å¹³æ”¾çš„ï¼ˆrotation -90 0 0ï¼‰
            const localX = point.x;
            const localZ = point.z; // åœ¨æ—‹è½¬åçš„åæ ‡ç³»ä¸­
            
            // å¸é™„åˆ°æœ€è¿‘çš„äº¤å‰ç‚¹
            const gridX = Math.round((localX + 0.375) / (0.75/18));
            const gridZ = Math.round((localZ + 0.375) / (0.75/18));
            
            // è¾¹ç•Œæ£€æŸ¥
            if(gridX < 0 || gridX > 18 || gridZ < 0 || gridZ > 18) return;
            
            // æ£€æŸ¥æ˜¯å¦å·²æœ‰æ£‹å­
            const exists = this.state.stones.find(s => s.gx === gridX && s.gz === gridZ);
            if(exists) return;
            
            this.placeStone(gridX, gridZ);
        });
    },
    
    placeStone(gx, gz) {
        const container = document.getElementById('stonesContainer');
        const step = 0.75 / 18;
        const x = -0.375 + gx * step;
        const z = -0.375 + gz * step;
        
        // åˆ›å»ºæ£‹å­å®ä½“
        const stone = document.createElement('a-sphere');
        const color = this.state.currentPlayer === 'black' ? '#0d0d0d' : '#f5f5f5';
        const yPos = 0.02 + (this.state.stones.length * 0.0001); // é˜² z-fighting
        
        stone.setAttribute('position', `${x} ${yPos} ${z}`);
        stone.setAttribute('radius', '0.018');
        stone.setAttribute('color', color);
        stone.setAttribute('shadow', 'cast: true');
        stone.setAttribute('class', 'stone');
        
        // è½å­åŠ¨ç”»ï¼ˆä»ä¸Šæ–¹è½ä¸‹ï¼‰
        stone.setAttribute('animation', {
            property: 'position',
            from: `${x} 0.2 ${z}`,
            to: `${x} ${yPos} ${z}`,
            dur: 400,
            easing: 'easeOutBounce'
        });
        
        // æè´¨ç»†èŠ‚ï¼ˆä½¿ç”¨ Babylon é£æ ¼çš„æè´¨å±æ€§é€šè¿‡ A-Frame è®¾ç½®ï¼‰
        if(this.state.currentPlayer === 'white') {
            stone.setAttribute('material', 'roughness: 0.2; metalness: 0.1');
        } else {
            stone.setAttribute('material', 'roughness: 0.4; metalness: 0.0');
        }
        
        container.appendChild(stone);
        
        // æ’­æ”¾å£°éŸ³
        const audio = document.getElementById('stoneSound');
        audio.currentTime = 0;
        audio.play().catch(e => {});
        
        // ä¿å­˜çŠ¶æ€
        this.state.stones.push({
            gx, gz, 
            player: this.state.currentPlayer,
            element: stone
        });
        
        // åˆ‡æ¢ç©å®¶
        this.state.currentPlayer = this.state.currentPlayer === 'black' ? 'white' : 'black';
        this.updateUI();
        
        // æ£€æŸ¥æå­ï¼ˆç®€å•é€»è¾‘ï¼šå››å‘¨è¢«å›´åˆ™æï¼Œå®é™…åº”å®ç°å®Œæ•´å›´æ£‹è§„åˆ™ï¼‰
        this.checkCaptures(gx, gz);
    },
    
    checkCaptures(x, z) {
        // ç®€åŒ–ç‰ˆï¼šä¸å®ç°å¤æ‚æå­é€»è¾‘ï¼Œä»…æ¼”ç¤ºæ”¾ç½®
        // å®é™…é¡¹ç›®åº”ä½¿ç”¨è¿é€šåŸŸç®—æ³•æ£€æŸ¥æ°”
    },
    
    updateUI() {
        document.getElementById('currentPlayer').textContent = 
            this.state.currentPlayer === 'black' ? 'é»‘æ–¹' : 'ç™½æ–¹';
        document.getElementById('currentPlayer').style.color = 
            this.state.currentPlayer === 'black' ? '#FFD700' : '#E0E0E0';
        document.getElementById('moveCount').textContent = this.state.stones.length;
    },
    
    reset() {
        const container = document.getElementById('stonesContainer');
        while(container.firstChild) {
            container.removeChild(container.firstChild);
        }
        this.state.stones = [];
        this.state.currentPlayer = 'black';
        this.updateUI();
    },
    
    undo() {
        if(this.state.stones.length === 0) return;
        const last = this.state.stones.pop();
        last.element.remove();
        this.state.currentPlayer = last.player; // å›é€€ç©å®¶
        this.updateUI();
    }
};

// ==================== å…¨å±€æ§åˆ¶å‡½æ•° ====================
function resetGame() {
    GameLogic.reset();
}

function undoMove() {
    GameLogic.undo();
}

function toggleMode() {
    // åˆ‡æ¢æ ‡è®°è¿½è¸ªå’Œè¡¨é¢æ”¾ç½®æ¨¡å¼
    const marker = document.getElementById('markerTarget');
    const status = document.getElementById('statusText');
    
    if(GameLogic.state.isARMode) {
        // åˆ‡æ¢åˆ°è¡¨é¢æ£€æµ‹æ¨¡å¼ï¼ˆéœ€è¦é‡æ–°åŠ è½½åœºæ™¯ä½¿ç”¨ hit-testï¼‰
        status.textContent = 'ğŸ“ è¡¨é¢æ”¾ç½®æ¨¡å¼å¼€å‘ä¸­ï¼Œå½“å‰è¯·ä½¿ç”¨æ ‡è®°æ¨¡å¼';
        alert('æç¤ºï¼šAR.js è¡¨é¢æ£€æµ‹éœ€è¦é¢å¤–çš„ Three.js é›†æˆï¼Œå½“å‰ç‰ˆæœ¬è¯·ä½¿ç”¨ Hiro æ ‡è®°æ¨¡å¼');
    } else {
        GameLogic.state.isARMode = true;
        status.textContent = 'ğŸ“± å¯¹å‡† Hiro æ ‡è®°ï¼ˆæ‰“å°æˆ–æ˜¾ç¤ºåœ¨å¦ä¸€å°è®¾å¤‡ä¸Šï¼‰';
    }
}

// ==================== åˆå§‹åŒ– ====================
window.addEventListener('load', () => {
    // å»¶è¿Ÿåˆå§‹åŒ–ç¡®ä¿ AR.js å°±ç»ª
    setTimeout(() => {
        GameLogic.init();
        
        // æ£€æŸ¥ç›¸æœºæƒé™
        if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    stream.getTracks().forEach(track => track.stop());
                })
                .catch(err => {
                    alert('è¯·å…è®¸ç›¸æœºæƒé™ä»¥ä½¿ç”¨ AR åŠŸèƒ½');
                });
        }
    }, 1000);
});

// å¤„ç†æ ‡è®°æ‰¾åˆ°/ä¸¢å¤±äº‹ä»¶
const marker = document.getElementById('markerTarget');
marker.addEventListener('markerFound', () => {
    document.getElementById('statusText').innerHTML = 'âœ… æ£€æµ‹åˆ°æ£‹ç›˜æ ‡è®°ï¼Œç‚¹å‡»ç½‘æ ¼äº¤å‰ç‚¹ä¸‹æ£‹<br><small>ä½¿ç”¨"æ‚”æ£‹"æŒ‰é’®æ’¤é”€è¯¯æ“ä½œ</small>';
    document.getElementById('markerHint').style.display = 'none';
});

marker.addEventListener('markerLost', () => {
    document.getElementById('statusText').textContent = 'ğŸ“± å¯¹å‡† Hiro æ ‡è®°ï¼ˆæ ‡è®°ä¸¢å¤±ï¼‰';
    document.getElementById('markerHint').style.display = 'block';
});
</script>

</body>
</html>
