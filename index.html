<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å›´æ£‹æ£‹ç›˜å¢å¼ºè¯†åˆ« Pro</title>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #1a1a1a; font-family: -apple-system, sans-serif; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #videoInput { display: none; }
        #canvasOutput { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 100%; max-height: 100%; box-shadow: 0 0 30px rgba(0,0,0,0.8); }
        
        .panel { position: absolute; background: rgba(0,0,0,0.85); color: white; padding: 15px; border-radius: 12px; backdrop-filter: blur(10px); z-index: 10; pointer-events: auto; border: 1px solid rgba(255,255,255,0.1); }
        #statusPanel { top: 20px; left: 20px; width: 240px; }
        #detailPanel { top: 20px; right: 20px; width: 180px; font-size: 12px; }
        #fpsCounter { bottom: 100px; right: 20px; font-family: monospace; color: #00ff00; font-size: 14px; }
        #controls { bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
        
        .stat-row { display: flex; justify-content: space-between; margin: 6px 0; font-size: 13px; }
        .stat-label { color: #aaa; }
        .stat-value { color: #fff; font-weight: 600; }
        .stat-value.good { color: #34C759; }
        .stat-value.warn { color: #FF9500; }
        .stat-value.bad { color: #FF3B30; }
        
        .progress-container { width: 100%; height: 8px; background: #333; border-radius: 4px; margin-top: 5px; overflow: hidden; position: relative; }
        #coverageBar { height: 100%; background: linear-gradient(90deg, #FF3B30 0%, #FF9500 50%, #34C759 100%); width: 0%; transition: width 0.2s ease-out; }
        #coverageText { position: absolute; right: 5px; top: -18px; font-size: 11px; color: #fff; }
        
        .grid-badge { display: inline-block; background: #007AFF; color: white; padding: 2px 8px; border-radius: 10px; font-size: 12px; margin-left: 5px; }
        .grid-badge.locked { background: #34C759; }
        
        .btn { background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 12px rgba(0,122,255,0.3); }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(0,122,255,0.4); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn.secondary { background: #5856D6; }
        .btn.danger { background: #FF3B30; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; z-index: 100; }
        .spinner { width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.2); border-top-color: #007AFF; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .corner-indicator { position: absolute; width: 20px; height: 20px; border: 3px solid; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 5; }
        .corner-visible { border-color: #34C759; background: rgba(52, 199, 89, 0.3); box-shadow: 0 0 10px #34C759; }
        .corner-missing { border-color: #FF3B30; background: rgba(255, 59, 48, 0.3); }
        
        .star-marker { position: absolute; width: 24px; height: 24px; transform: translate(-50%, -50%); pointer-events: none; z-index: 6; }
        .star-marker::before { content: 'â˜…'; color: #FFD700; font-size: 20px; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        
        #previewMap { position: absolute; bottom: 100px; left: 20px; width: 120px; height: 120px; background: rgba(0,0,0,0.8); border-radius: 8px; border: 2px solid #333; display: none; }
    </style>
</head>
<body>

<div id="container">
    <div id="loading">
        <div class="spinner"></div>
        <div style="font-size: 16px; font-weight: 600;">OpenCV å¼•æ“åŠ è½½ä¸­</div>
        <div style="font-size: 12px; opacity: 0.7; margin-top: 8px;">é¦–æ¬¡åŠ è½½çº¦éœ€ 3-5 ç§’...</div>
    </div>
    
    <video id="videoInput" playsinline></video>
    <canvas id="canvasOutput"></canvas>
    
    <!-- è§’ç‚¹æŒ‡ç¤ºå™¨å®¹å™¨ -->
    <div id="cornerContainer"></div>
    <!-- æ˜Ÿä½æ ‡è®°å®¹å™¨ -->
    <div id="starContainer"></div>
    
    <div id="ui" style="display: none;">
        <div class="panel" id="statusPanel">
            <div style="font-weight: 700; margin-bottom: 12px; color: #007AFF; font-size: 16px;">
                ğŸ¯ æ™ºèƒ½æ£‹ç›˜è¯†åˆ«
            </div>
            <div class="stat-row">
                <span class="stat-label">æ£‹ç›˜è§„æ ¼</span>
                <span class="stat-value" id="boardType">
                    æ£€æµ‹ä¸­... <span class="grid-badge" id="lockBadge">AUTO</span>
                </span>
            </div>
            <div class="stat-row">
                <span class="stat-label">è§†é‡è¦†ç›–ç‡</span>
                <span class="stat-value" id="coverageValue">0%</span>
            </div>
            <div class="progress-container">
                <div id="coverageBar"></div>
                <span id="coverageText">0%</span>
            </div>
            <div class="stat-row" style="margin-top: 10px;">
                <span class="stat-label">è§’ç‚¹å¯è§æ€§</span>
                <span class="stat-value" id="cornerStatus">0/4</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">æ˜Ÿä½è¯†åˆ«</span>
                <span class="stat-value" id="starStatus">0/9</span>
            </div>
        </div>
        
        <div class="panel" id="detailPanel">
            <div style="font-weight: 600; margin-bottom: 8px; color: #FFD700;">ğŸ“Š æ£€æµ‹è¯¦æƒ…</div>
            <div class="stat-row">
                <span class="stat-label">é€è§†è´¨é‡</span>
                <span class="stat-value" id="qualityText">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">ç½‘æ ¼ç½®ä¿¡åº¦</span>
                <span class="stat-value" id="gridConf">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">å»ºè®®æ“ä½œ</span>
                <span class="stat-value" id="suggestion">ç§»åŠ¨ç›¸æœº</span>
            </div>
        </div>
        
        <div class="panel" id="fpsCounter">FPS: <span id="fps">0</span></div>
        
        <div id="controls">
            <button class="btn" id="btnStart" onclick="startCamera()" disabled>ğŸ¥ å¯åŠ¨ç›¸æœº</button>
            <button class="btn secondary" onclick="togglePause()" id="btnPause">â¸ï¸ æš‚åœ</button>
            <button class="btn danger" onclick="resetDetection()">ğŸ”„ é‡ç½®</button>
        </div>
    </div>
</div>

<script>
let cv = null;
let video = document.getElementById('videoInput');
let canvas = document.getElementById('canvasOutput');
let ctx = canvas.getContext('2d');
let isProcessing = false;
let isPaused = false;
let fps = 0, lastTime = 0;

// æ£€æµ‹çŠ¶æ€
let state = {
    initialized: false,
    gridSize: 19,      // 9, 13, æˆ– 19
    locked: false,     // é”å®šåä¸å†æ”¹å˜
    coverage: 0,       // 0-100
    corners: [],       // å½“å‰æ£€æµ‹åˆ°çš„è§’ç‚¹
    visibleCorners: 0, // å¯è§è§’ç‚¹æ•°
    stars: [],         // æ£€æµ‹åˆ°çš„æ˜Ÿä½
    history: [],       // è¦†ç›–ç‡å†å²ï¼ˆå¹³æ»‘ç”¨ï¼‰
    lastValidTime: 0   // ä¸Šæ¬¡æœ‰æ•ˆæ£€æµ‹æ—¶é—´
};

// é…ç½®
const CONFIG = {
    minAreaRatio: 0.05,      // æœ€å°æ£‹ç›˜é¢ç§¯å æ¯”
    maxAreaRatio: 0.9,       // æœ€å¤§æ£‹ç›˜é¢ç§¯å æ¯”
    coverageSmoothFrames: 5, // å¹³æ»‘å¸§æ•°
    starThreshold: 0.6,      // æ˜Ÿä½æ£€æµ‹é˜ˆå€¼
    relockThreshold: 2000    // é‡æ–°é”å®šæ—¶é—´(ms)
};

function onOpenCvReady() {
    cv = window.cv;
    document.getElementById('loading').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    document.getElementById('btnStart').disabled = false;
    console.log('OpenCV å°±ç»ª');
}

async function startCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { 
                facingMode: 'environment',
                width: { ideal: 1280 },
                height: { ideal: 720 }
            }
        });
        video.srcObject = stream;
        video.play();
        
        document.getElementById('btnStart').textContent = 'âœ… è¿è¡Œä¸­';
        document.getElementById('btnStart').disabled = true;
        
        video.onloadedmetadata = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            isProcessing = true;
            requestAnimationFrame(processLoop);
        };
    } catch(err) {
        alert('ç›¸æœºå¯åŠ¨å¤±è´¥: ' + err.message);
    }
}

function togglePause() {
    isPaused = !isPaused;
    document.getElementById('btnPause').textContent = isPaused ? 'â–¶ï¸ ç»§ç»­' : 'â¸ï¸ æš‚åœ';
}

function resetDetection() {
    state.initialized = false;
    state.locked = false;
    state.gridSize = 19;
    state.history = [];
    document.getElementById('boardType').innerHTML = 'æ£€æµ‹ä¸­... <span class="grid-badge" id="lockBadge">AUTO</span>';
    document.getElementById('lockBadge').className = 'grid-badge';
    updateCornerIndicators([]);
    updateStarMarkers([]);
}

function processLoop(timestamp) {
    if (!isProcessing) return;
    
    // FPS è®¡ç®—
    if (timestamp - lastTime > 1000) {
        document.getElementById('fps').textContent = fps;
        fps = 0;
        lastTime = timestamp;
    }
    fps++;
    
    if (!isPaused && video.readyState === 4) {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        detectBoard();
    }
    
    requestAnimationFrame(processLoop);
}

function detectBoard() {
    try {
        // è¯»å–å¸§
        let src = cv.imread(canvas);
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        
        // é¢„å¤„ç†
        let blurred = new cv.Mat();
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
        
        // è‡ªé€‚åº”é˜ˆå€¼ï¼ˆåº”å¯¹å…‰ç…§å˜åŒ–ï¼‰
        let binary = new cv.Mat();
        cv.adaptiveThreshold(blurred, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
        
        // å½¢æ€å­¦æ“ä½œè¿æ¥æ–­çº¿
        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
        let morph = new cv.Mat();
        cv.morphologyEx(binary, morph, cv.MORPH_CLOSE, kernel, new cv.Point(-1,-1), 2);
        
        // æŸ¥æ‰¾è½®å»“
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(morph, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        
        // å¯»æ‰¾æœ€ä½³æ£‹ç›˜è½®å»“
        let bestContour = findBestContour(contours);
        
        if (bestContour) {
            processValidBoard(src, bestContour, gray);
        } else {
            handleNoBoard();
        }
        
        // æ¸…ç†
        src.delete(); gray.delete(); blurred.delete(); binary.delete();
        morph.delete(); kernel.delete(); contours.delete(); hierarchy.delete();
        if(bestContour) bestContour.delete();
        
    } catch(e) {
        console.error('æ£€æµ‹é”™è¯¯:', e);
    }
}

function findBestContour(contours) {
    let best = null;
    let bestScore = 0;
    const imgArea = canvas.width * canvas.height;
    
    for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        let areaRatio = area / imgArea;
        
        // é¢ç§¯è¿‡æ»¤
        if (areaRatio < CONFIG.minAreaRatio || areaRatio > CONFIG.maxAreaRatio) {
            cnt.delete();
            continue;
        }
        
        // å¤šè¾¹å½¢è¿‘ä¼¼
        let peri = cv.arcLength(cnt, true);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
        
        // å¿…é¡»æ˜¯å››è¾¹å½¢
        if (approx.rows !== 4) {
            approx.delete();
            cnt.delete();
            continue;
        }
        
        // è®¡ç®—çŸ©å½¢åº¦ï¼ˆè¶Šæ¥è¿‘çŸ©å½¢åˆ†æ•°è¶Šé«˜ï¼‰
        let rect = cv.minAreaRect(cnt);
        let rectArea = rect.size.width * rect.size.height;
        let rectangularity = area / rectArea;
        
        // ç»¼åˆè¯„åˆ†ï¼šé¢ç§¯é€‚ä¸­ + çŸ©å½¢åº¦é«˜
        let score = areaRatio * rectangularity;
        
        if (score > bestScore) {
            if (best) best.delete();
            best = approx.clone();
            bestScore = score;
        }
        
        approx.delete();
        cnt.delete();
    }
    
    return best;
}

function processValidBoard(src, contour, gray) {
    // æå–è§’ç‚¹
    let corners = [];
    for (let i = 0; i < 4; i++) {
        corners.push({
            x: contour.data32S[i * 2],
            y: contour.data32S[i * 2 + 1]
        });
    }
    
    // æ’åºï¼šå·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹
    corners = sortCorners(corners);
    state.corners = corners;
    
    // è®¡ç®—é€è§†å˜æ¢
    const size = 800;
    let srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        corners[0].x, corners[0].y,
        corners[1].x, corners[1].y,
        corners[2].x, corners[2].y,
        corners[3].x, corners[3].y
    ]);
    let dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, size, 0, size, size, 0, size]);
    let M = cv.getPerspectiveTransform(srcPts, dstPts);
    let invM = cv.getPerspectiveTransform(dstPts, srcPts);
    
    // é€è§†æ ¡æ­£
    let warped = new cv.Mat();
    cv.warpPerspective(gray, warped, M, new cv.Size(size, size));
    
    // é¦–æ¬¡æ£€æµ‹ï¼šåˆ¤å®šè·¯æ•°
    if (!state.initialized) {
        detectGridSize(warped);
    }
    
    // è®¡ç®—è¦†ç›–ç‡ï¼ˆåŸºäºè§’ç‚¹å¯è§æ€§å’Œç½‘æ ¼å®Œæ•´æ€§ï¼‰
    let coverage = calculateCoverage(warped, corners);
    state.coverage = smoothCoverage(coverage);
    
    // æ£€æµ‹æ˜Ÿä½
    let stars = detectStars(warped, invM);
    state.stars = stars;
    
    // ç»˜åˆ¶
    drawBoardOverlay(corners, invM);
    updateCornerIndicators(corners);
    updateStarMarkers(stars);
    updateUI(true);
    
    // æ¸…ç†
    warped.delete(); M.delete(); invM.delete(); srcPts.delete(); dstPts.delete();
}

function sortCorners(pts) {
    // æŒ‰ y æ’åºï¼Œåˆ†ä¸ºä¸Šä¸‹ä¸¤ç»„
    pts.sort((a, b) => a.y - b.y);
    let top = pts.slice(0, 2).sort((a, b) => a.x - b.x);
    let bottom = pts.slice(2).sort((a, b) => a.x - b.x);
    return [top[0], top[1], bottom[1], bottom[0]]; // å·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹
}

function detectGridSize(warped) {
    // ä½¿ç”¨ Hough çº¿æ£€æµ‹ç»Ÿè®¡çº¿æ¡æ•°é‡
    let edges = new cv.Mat();
    cv.Canny(warped, edges, 50, 150);
    
    let lines = new cv.Mat();
    cv.HoughLinesP(edges, lines, 1, Math.PI / 180, 50, 100, 10);
    
    // åˆ†ç±»æ¨ªç«–çº¿
    let horizontal = 0, vertical = 0;
    for (let i = 0; i < lines.rows; i++) {
        let x1 = lines.data32S[i * 4];
        let y1 = lines.data32S[i * 4 + 1];
        let x2 = lines.data32S[i * 4 + 2];
        let y2 = lines.data32S[i * 4 + 3];
        
        let angle = Math.abs(Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI);
        if (angle < 20 || angle > 160) horizontal++;
        else if (angle > 70 && angle < 110) vertical++;
    }
    
    // æ ¹æ®çº¿æ•°åˆ¤å®šè·¯æ•°ï¼ˆè€ƒè™‘æ£€æµ‹è¯¯å·®ï¼‰
    let avgLines = (horizontal + vertical) / 2;
    let detectedSize = 19;
    
    if (avgLines < 15) detectedSize = 9;
    else if (avgLines < 25) detectedSize = 13;
    else detectedSize = 19;
    
    state.gridSize = detectedSize;
    state.initialized = true;
    state.locked = true;
    
    // æ›´æ–° UI
    let badge = document.getElementById('lockBadge');
    badge.textContent = 'LOCKED';
    badge.className = 'grid-badge locked';
    document.getElementById('boardType').innerHTML = `${detectedSize} è·¯æ£‹ç›˜ ${badge.outerHTML}`;
    
    edges.delete(); lines.delete();
}

function calculateCoverage(warped, corners) {
    // åŸºäºå¤šä¸ªå› ç´ è®¡ç®—è¦†ç›–ç‡
    
    // 1. è§’ç‚¹æ˜¯å¦åœ¨ç”»é¢å†…
    let visibleCorners = corners.filter(p => 
        p.x > 50 && p.x < canvas.width - 50 && 
        p.y > 50 && p.y < canvas.height - 50
    ).length;
    state.visibleCorners = visibleCorners;
    
    // 2. æ£‹ç›˜åœ¨ç”»é¢ä¸­çš„é¢ç§¯å æ¯”
    let boardArea = Math.abs(
        (corners[0].x * corners[1].y + corners[1].x * corners[2].y + 
         corners[2].x * corners[3].y + corners[3].x * corners[0].y) -
        (corners[0].y * corners[1].x + corners[1].y * corners[2].x + 
         corners[2].y * corners[3].x + corners[3].y * corners[0].x)
    ) / 2;
    let areaRatio = boardArea / (canvas.width * canvas.height);
    
    // 3. å†…éƒ¨ç½‘æ ¼æ¸…æ™°åº¦ï¼ˆè¾¹ç¼˜å¯†åº¦ï¼‰
    let edges = new cv.Mat();
    cv.Canny(warped, edges, 80, 200);
    let edgeDensity = cv.countNonZero(edges) / (warped.rows * warped.cols);
    edges.delete();
    
    // ç»¼åˆè®¡ç®—ï¼ˆè§’ç‚¹æƒé‡æœ€é«˜ï¼‰
    let coverage = (visibleCorners / 4) * 60 + 
                   Math.min(areaRatio * 200, 30) + 
                   Math.min(edgeDensity * 1000, 10);
    
    return Math.min(100, Math.round(coverage));
}

function smoothCoverage(current) {
    state.history.push(current);
    if (state.history.length > CONFIG.coverageSmoothFrames) {
        state.history.shift();
    }
    // ä½¿ç”¨ä¸­ä½æ•°æ»¤æ³¢æŠ—æŠ–åŠ¨
    let sorted = [...state.history].sort((a, b) => a - b);
    return sorted[Math.floor(sorted.length / 2)];
}

function detectStars(warped, invM) {
    // åœ¨çŸ«æ­£åçš„å›¾åƒä¸Šæ£€æµ‹é»‘ç‚¹ï¼ˆæ˜Ÿä½ï¼‰
    let binary = new cv.Mat();
    cv.threshold(warped, binary, 80, 255, cv.THRESH_BINARY_INV);
    
    // æŸ¥æ‰¾è½®å»“
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(binary, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
    
    let stars = [];
    const size = warped.rows;
    const step = size / (state.gridSize - 1);
    
    // æ ‡å‡†æ˜Ÿä½ä½ç½®
    let starPositions = getStarPositions(state.gridSize);
    
    for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        
        // è¿‡æ»¤å¤§å°ï¼ˆæ˜Ÿä½å¤§å°çº¦ä¸º cell çš„ 20-40%ï¼‰
        let expectedArea = Math.PI * Math.pow(step * 0.15, 2);
        if (area < expectedArea * 0.3 || area > expectedArea * 3) {
            cnt.delete();
            continue;
        }
        
        // è·å–ä¸­å¿ƒ
        let moments = cv.moments(cnt);
        let cx = moments.m10 / moments.m00;
        let cy = moments.m01 / moments.m00;
        
        // æ£€æŸ¥æ˜¯å¦æ¥è¿‘æ ‡å‡†æ˜Ÿä½
        let gridX = Math.round(cx / step);
        let gridY = Math.round(cy / step);
        
        let isStar = starPositions.some(pos => 
            Math.abs(pos.x - gridX) <= 1 && Math.abs(pos.y - gridY) <= 1
        );
        
        if (isStar) {
            // æ˜ å°„å›åŸå›¾åæ ‡
            let pt = cv.matFromArray(1, 1, cv.CV_32FC2, [cx, cy]);
            let dst = new cv.Mat();
            cv.perspectiveTransform(pt, dst, invM);
            
            stars.push({
                x: dst.data32F[0],
                y: dst.data32F[1],
                gridX: gridX,
                gridY: gridY
            });
            
            pt.delete(); dst.delete();
        }
        
        cnt.delete();
    }
    
    binary.delete(); contours.delete(); hierarchy.delete();
    
    // å»é‡ï¼ˆåŒä¸€æ˜Ÿä½å¯èƒ½æ£€æµ‹å¤šæ¬¡ï¼‰
    return stars.filter((star, idx, self) => 
        idx === self.findIndex(s => s.gridX === star.gridX && s.gridY === star.gridY)
    );
}

function getStarPositions(size) {
    // è¿”å›æ ‡å‡†æ˜Ÿä½åæ ‡
    if (size === 9) return [{x:2,y:2}, {x:2,y:6}, {x:4,y:4}, {x:6,y:2}, {x:6,y:6}];
    if (size === 13) return [
        {x:3,y:3}, {x:3,y:9}, {x:6,y:6}, {x:9,y:3}, {x:9,y:9}
    ];
    // 19è·¯
    return [
        {x:3,y:3}, {x:3,y:9}, {x:3,y:15},
        {x:9,y:3}, {x:9,y:9}, {x:9,y:15},
        {x:15,y:3}, {x:15,y:9}, {x:15,y:15}
    ];
}

function drawBoardOverlay(corners, invM) {
    // ç»˜åˆ¶æ£‹ç›˜è¾¹æ¡†
    ctx.strokeStyle = '#007AFF';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(corners[0].x, corners[0].y);
    corners.forEach((p, i) => {
        if (i > 0) ctx.lineTo(p.x, p.y);
    });
    ctx.closePath();
    ctx.stroke();
    
    // ç»˜åˆ¶å®Œæ•´ç½‘æ ¼çº¿
    const size = 800;
    const step = size / (state.gridSize - 1);
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.lineWidth = 1.5;
    
    // ç”Ÿæˆæ‰€æœ‰ç½‘æ ¼çº¿ç«¯ç‚¹
    let lines = [];
    for (let i = 0; i < state.gridSize; i++) {
        // æ¨ªçº¿
        lines.push(0, i*step, size, i*step);
        // ç«–çº¿
        lines.push(i*step, 0, i*step, size);
    }
    
    // æ‰¹é‡å˜æ¢å¹¶ç»˜åˆ¶
    let srcMat = cv.matFromArray(lines.length/2, 1, cv.CV_32FC2, lines);
    let dstMat = new cv.Mat();
    cv.perspectiveTransform(srcMat, dstMat, invM);
    
    for (let i = 0; i < dstMat.rows; i++) {
        let x1 = dstMat.data32F[i*2];
        let y1 = dstMat.data32F[i*2+1];
        let x2 = dstMat.data32F[(i+1)*2];
        let y2 = dstMat.data32F[(i+1)*2+1];
        
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    
    srcMat.delete(); dstMat.delete();
}

function updateCornerIndicators(corners) {
    const container = document.getElementById('cornerContainer');
    container.innerHTML = '';
    
    const names = ['å·¦ä¸Š', 'å³ä¸Š', 'å³ä¸‹', 'å·¦ä¸‹'];
    corners.forEach((corner, idx) => {
        let div = document.createElement('div');
        div.className = 'corner-indicator corner-visible';
        div.style.left = corner.x + 'px';
        div.style.top = corner.y + 'px';
        div.title = names[idx];
        container.appendChild(div);
    });
}

function updateStarMarkers(stars) {
    const container = document.getElementById('starContainer');
    container.innerHTML = '';
    
    stars.forEach(star => {
        let div = document.createElement('div');
        div.className = 'star-marker';
        div.style.left = star.x + 'px';
        div.style.top = star.y + 'px';
        container.appendChild(div);
    });
}

function handleNoBoard() {
    state.corners = [];
    state.visibleCorners = 0;
    state.stars = [];
    updateCornerIndicators([]);
    updateStarMarkers([]);
    updateUI(false);
}

function updateUI(detected) {
    // è¦†ç›–ç‡
    let cov = state.coverage;
    document.getElementById('coverageValue').textContent = cov + '%';
    document.getElementById('coverageValue').className = 'stat-value ' + (cov > 80 ? 'good' : cov > 40 ? 'warn' : 'bad');
    document.getElementById('coverageBar').style.width = cov + '%';
    document.getElementById('coverageText').textContent = cov + '%';
    
    // è§’ç‚¹
    document.getElementById('cornerStatus').textContent = `${state.visibleCorners}/4`;
    
    // æ˜Ÿä½
    let starCount = state.stars.length;
    let expectedStars = state.gridSize === 19 ? 9 : state.gridSize === 13 ? 5 : 5;
    document.getElementById('starStatus').textContent = `${starCount}/${expectedStars}`;
    
    // è¯¦æƒ…é¢æ¿
    if (detected) {
        let quality = state.coverage > 90 ? 'ä¼˜ç§€' : state.coverage > 70 ? 'è‰¯å¥½' : 'ä¸€èˆ¬';
        document.getElementById('qualityText').textContent = quality;
        document.getElementById('qualityText').className = 'stat-value ' + (quality === 'ä¼˜ç§€' ? 'good' : quality === 'è‰¯å¥½' ? 'warn' : 'bad');
        
        let conf = (starCount / expectedStars * 100).toFixed(0) + '%';
        document.getElementById('gridConf').textContent = conf;
        
        let suggestion = state.coverage < 60 ? 'è¯·é è¿‘æ£‹ç›˜' : 
                        state.visibleCorners < 4 ? 'è°ƒæ•´è§’åº¦' : 
                        starCount < expectedStars ? 'æ”¹å–„å…‰çº¿' : 'æ£€æµ‹æ­£å¸¸';
        document.getElementById('suggestion').textContent = suggestion;
    } else {
        document.getElementById('qualityText').textContent = '-';
        document.getElementById('gridConf').textContent = '-';
        document.getElementById('suggestion').textContent = 'å¯»æ‰¾æ£‹ç›˜...';
    }
}

// æ¸…ç†
window.onbeforeunload = () => {
    isProcessing = false;
};
</script>

</body>
</html>
