<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR 实体围棋盘识别</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
        video { display: none; }
        canvas {
            position: absolute;
            width: 100%; height: 100%;
            left: 0; top: 0;
            /* 不再镜像翻转，因为要对齐真实世界 */
        }
        #status {
            position: absolute; top: 20px; left: 20px; color: lime; z-index: 10;
            font-family: sans-serif; background: rgba(0,0,0,0.7); padding: 8px; border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="status">正在加载 OpenCV 和 AI 模型，请稍候... (可能需要十几秒)</div>
    <video id="input_video" playsinline webkit-playsinline></video>
    <canvas id="output_canvas"></canvas>
    <canvas id="process_canvas" style="display:none;"></canvas>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const processCanvas = document.getElementById('process_canvas');
        const processCtx = processCanvas.getContext('2d');
        const statusDiv = document.getElementById('status');

        let isOpenCvReady = false;
        let isHandsReady = false;
        let detectedBoardCorners = null; // 存储检测到的棋盘四个角
        const boardSize = 19;
        let stones = []; 

        // ----- OpenCV 部分 -----
        function onOpenCvReady() {
            isOpenCvReady = true;
            checkReady();
        }

        function checkReady() {
            if (isOpenCvReady && isHandsReady) {
                statusDiv.innerText = "系统就绪！请将完整的围棋盘放入画面，确保光线充足且背景有对比度。";
                startCamera();
            }
        }

        // 核心：寻找棋盘
        function findGameBoard(srcMat) {
            let gray = new cv.Mat();
            let blurred = new cv.Mat();
            let edges = new cv.Mat();
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();

            // 1. 预处理 pipeline
            cv.cvtColor(srcMat, gray, cv.COLOR_RGBA2GRAY);
            // 高斯模糊减少噪点 (核大小 (5,5), sigmaX 0)
            cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
            // Canny 边缘检测 (阈值需要根据实际光线调整，这里取 50, 150)
            cv.Canny(blurred, edges, 50, 150);

            // 2. 寻找轮廓
            // RETR_EXTERNAL 只找最外层轮廓，CHAIN_APPROX_SIMPLE 压缩垂直/水平/对角线段
            cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            let maxArea = 0;
            let bestApprox = null;
            const minAreaThreshold = (srcMat.cols * srcMat.rows) * 0.1; // 至少占屏幕 10% 面积

            // 3. 遍历找到的轮廓
            for (let i = 0; i < contours.size(); ++i) {
                let cnt = contours.get(i);
                let area = cv.contourArea(cnt);

                if (area > minAreaThreshold) {
                    let peri = cv.arcLength(cnt, true);
                    let approx = new cv.Mat();
                    // 多边形拟合： epsilon 越小拟合越精确，0.02 是经验值
                    cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

                    // 如果拟合结果有 4 个顶点，且是凸多边形，且面积最大
                    if (approx.rows === 4 && cv.isContourConvex(approx) && area > maxArea) {
                        maxArea = area;
                        if (bestApprox) bestApprox.delete();
                        bestApprox = approx; // 找到了潜在的棋盘
                    } else {
                        approx.delete();
                    }
                }
            }

            // 清理内存
            gray.delete(); blurred.delete(); edges.delete(); contours.delete(); hierarchy.delete();

            if (bestApprox) {
                // 提取四个角的坐标
                let corners = [];
                for (let i = 0; i < 4; i++) {
                    corners.push({ x: bestApprox.data32S[i * 2], y: bestApprox.data32S[i * 2 + 1] });
                }
                bestApprox.delete();
                // 需要对角点进行排序（例如：左上，右上，右下，左下），这里暂略，假设顺序大致正确
                return corners;
            }
            return null;
        }


        // ----- MediaPipe & 主循环 -----
        function onHandsResults(results) {
            // 1. 准备画布
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            // 2. 每隔几帧运行一次 OpenCV (为了性能，不要每帧都跑)
            // 这里简化为每帧都跑，如果卡顿需要降频
            if (isOpenCvReady) {
                // 将当前帧绘制到处理用的 Canvas
                processCtx.drawImage(results.image, 0, 0, processCanvas.width, processCanvas.height);
                // 从 Canvas 读取图像数据到 OpenCV Mat
                let srcMat = cv.imread(processCanvas);
                // 尝试寻找棋盘
                detectedBoardCorners = findGameBoard(srcMat);
                srcMat.delete();
            }

            // 3. 绘制识别状态
            if (detectedBoardCorners) {
                // 绘制找到的棋盘边界（绿色框）
                canvasCtx.beginPath();
                canvasCtx.strokeStyle = '#00FF00';
                canvasCtx.lineWidth = 4;
                canvasCtx.moveTo(detectedBoardCorners[0].x, detectedBoardCorners[0].y);
                for (let i = 1; i < 4; i++) {
                    canvasCtx.lineTo(detectedBoardCorners[i].x, detectedBoardCorners[i].y);
                }
                canvasCtx.closePath();
                canvasCtx.stroke();
                statusDiv.innerText = "✅ 已锁定实体棋盘";

                // 【未来扩展】：在这里进行透视变换，绘制虚拟棋子网格
                drawVirtualStonesOnPhysicalBoard(detectedBoardCorners);

            } else {
                statusDiv.innerText = "⚠️ 未检测到棋盘。请调整角度，确保背景对比清晰。";
            }

            // 4. 绘制手势 (调试用)
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // ... (保留之前的手势绘制代码用于调试)
                drawConnectors(canvasCtx, results.multiHandLandmarks[0], HAND_CONNECTIONS, {color: '#FFFFFF', lineWidth: 1});
            }
            canvasCtx.restore();
        }

        // 一个占位函数，演示未来如何在物理棋盘上画子
        function drawVirtualStonesOnPhysicalBoard(corners) {
             // 这里需要复杂的单应性矩阵计算 (Homography)
             // 将 2D 屏幕坐标映射到 3D 棋盘平面。
             // 作为演示，我们只在检测到的中心画一个红点
             let centerX = (corners[0].x + corners[2].x) / 2;
             let centerY = (corners[0].y + corners[2].y) / 2;
             canvasCtx.fillStyle = 'red';
             canvasCtx.beginPath();
             canvasCtx.arc(centerX, centerY, 10, 0, Math.PI*2);
             canvasCtx.fill();
        }


        // ----- 初始化 -----
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onHandsResults);
        isHandsReady = true;
        statusDiv.innerText += " | 手势模型已加载";
        checkReady();

        function startCamera() {
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    // 同步 Canvas 尺寸
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    processCanvas.width = videoElement.videoWidth; // 降低处理分辨率可提高性能
                    processCanvas.height = videoElement.videoHeight;
                    await hands.send({image: videoElement});
                },
                // 尝试请求较高的分辨率以利于识别，但会增加发热
                width: 1280, height: 720,
                facingMode: "environment" // 使用后置摄像头
            });
            camera.start();
        }
        
        // 窗口调整处理
        window.addEventListener('resize', () => {
             canvasElement.width = window.innerWidth;
             canvasElement.height = window.innerHeight;
        });

    </script>
</body>
</html>
